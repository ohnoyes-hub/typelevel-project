package com.ohnoyes.jobsboard.foundations

import cats.effect.{IO, IOApp, Resource}

import java.io.{File, FileWriter, PrintWriter}
import scala.io.StdIn
import scala.concurrent.duration.*

object CatsEffect extends IOApp.Simple {

  /*
    describing computations as values
   */

  // IO = data structure describing arbitrary computations (including side effects)
  val firstIO: IO[Int] = IO.pure(42)
  val delayedIO: IO[Int] = IO{
    // complex code
    println("I am doing something important")
    67
  }

  def evaluateIO[A](io: IO[A]): Unit = {
    import cats.effect.unsafe.implicits.global // "platform"
    val meaningOfLife = io.unsafeRunSync()
    println(s"the meaning of life is $meaningOfLife")
  }

  // transformations for IO
  // map + flatMap
  val improvedMeaningOfLife = firstIO.map(_ * 2)
  val printedMeaningOfLife = firstIO.flatMap(mol => IO(println(s"meaning of life is $mol")))
  // for-comprehensions
  def smallProgram(): IO[Unit] = for {
    line1 <- IO(StdIn.readLine())
    line2 <- IO(StdIn.readLine())
    _ <- IO(println(s"you said $line1 and $line2"))
  } yield ()

  // old style of standard Scala apps
//  def main(args: Array[String]): Unit = {
//    evaluateIO(smallProgram())
//  }

  // raise/"catch" errors
  val aFailure: IO[Int] = IO.raiseError(new RuntimeException("oh noes, a proper failure"))
  val dealWithIt = aFailure.handleErrorWith { // try-recover
    case _: RuntimeException => IO(println("we recovered!"))
  }

  // fibers = "lightweight threads"
  // *> = "and then"
  val delayedPrint = IO.sleep(1.second) *> IO(println("delayed print"))
  val manyPrints = for {
    fib1 <- delayedPrint.start
    fib2 <- delayedPrint.start
    _ <- fib1.join // join by blocking the calling fiber (fib1 joins the main fiber)
    _ <- fib2.join
  } yield ()
  /*
  join semantically block the calling fiber until the target fiber has completed its execution. When you join a fiber, you are essentially waiting for the result of that fiber's computation without blocking any actual threads.
  The join method is then called on this fiber, which waits for the fiber to complete and retrieves its result. The main fiber continues executing other operations (like printing to the console) without being blocked by the join.
   */

  val cancelledFiber = for {
    fib <- delayedPrint.onCancel(IO(println("I was cancelled"))).start // this takes 1 second to run
    _ <- IO.sleep(500.millis) *> IO(println("cancelling fiber")) *> fib.cancel // this takes 500 milliseconds to run, so it will cancel the fiber
    _ <- fib.join
  } yield ()

  // uncancelation
  val ignoredCancellation = for {
    fib <- IO.uncancelable(_ => delayedPrint.onCancel(IO(println("I was cancelled")))).start
    _ <- IO.sleep(500.millis) *> IO(println("cancelling fiber")) *> fib.cancel
    _ <- fib.join
  } yield ()

  // resources
  val readingResource = Resource.make(
    IO(scala.io.Source.fromFile("src/main/scala/com/ohnoyes/jobsboard/foundations/CatsEffect.scala"))
  ) (source => IO(println("closing resource")) *> IO(source.close()))
  val readingEffect = readingResource.use(source => IO(source.getLines().foreach(println)))

  // compose resources
  val copiedFileResource = Resource.make(IO(new PrintWriter(
    new FileWriter(new File("src/main/resources/dumpedFile.txt"))))
  ) { writer =>
    IO(println("closing writer")) *> IO(writer.close())
  }
  val compositeResource = for {
    source <- readingResource
    destination <- copiedFileResource
  } yield (source, destination)

  val copyFileEffect = compositeResource.use {
    case (source, destination) => IO(source.getLines().foreach(line => destination.println(line)))
  }

  // CE apps have a "run" method returning an IO, which will internally be evaluated in a main function
  override def run = copyFileEffect
}
